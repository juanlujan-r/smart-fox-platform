/* ==========================================================================
   SMART FOX SOLUTIONS - MASTER DATABASE SCHEMA (CLEANED & PRODUCTION-READY)
   Date: 2026-02-05
   Purpose: Complete schema with RLS, triggers, indexes, and fixes
   ========================================================================== */

-- ============================================================================
-- 1. HELPER FUNCTIONS (Must be first to avoid circular dependencies)
-- ============================================================================

CREATE OR REPLACE FUNCTION public.check_is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND role IN ('supervisor', 'gerente')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- 2. PROFILES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    role text CHECK (role IN ('empleado', 'supervisor', 'gerente')) DEFAULT 'empleado',
    full_name text,
    document_id text,
    document_type text DEFAULT 'CC',
    hiring_date date DEFAULT CURRENT_DATE,
    contract_type text DEFAULT 'Indefinido',
    base_salary numeric DEFAULT 0,
    minute_rate numeric DEFAULT 0,
    personal_data jsonb DEFAULT '{"phone": "", "address": "", "city": "", "emergency_name": "", "emergency_phone": ""}'::jsonb,
    medical_data jsonb DEFAULT '{"eps": "", "arl": "", "blood_type": "", "allergies": "", "pension": ""}'::jsonb,
    sizes_data jsonb DEFAULT '{"shirt": "", "pants": "", "shoes": ""}'::jsonb,
    updated_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users view own profile" ON public.profiles;
CREATE POLICY "Users view own profile" ON public.profiles 
FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users update own profile" ON public.profiles;
CREATE POLICY "Users update own profile" ON public.profiles 
FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins view all profiles" ON public.profiles;
CREATE POLICY "Admins view all profiles" ON public.profiles 
FOR SELECT USING (public.check_is_admin());

DROP POLICY IF EXISTS "Admins update all profiles" ON public.profiles;
CREATE POLICY "Admins update all profiles" ON public.profiles 
FOR UPDATE USING (public.check_is_admin());

-- Trigger for minute rate calculation
CREATE OR REPLACE FUNCTION public.calculate_minute_rate()
RETURNS trigger AS $$
BEGIN
    IF NEW.base_salary IS DISTINCT FROM OLD.base_salary AND NEW.base_salary IS NOT NULL THEN
        -- Ley 2101 Colombia: 42 Horas Semanales -> 210 Horas Mensuales -> 12600 Minutos
        NEW.minute_rate := NEW.base_salary / 12600;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_minute_rate ON public.profiles;
CREATE TRIGGER update_minute_rate BEFORE INSERT OR UPDATE ON public.profiles 
FOR EACH ROW EXECUTE FUNCTION public.calculate_minute_rate();

DROP TRIGGER IF EXISTS update_updated_at_profiles ON public.profiles;
CREATE TRIGGER update_updated_at_profiles BEFORE UPDATE ON public.profiles 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Create index for profiles
CREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role);

-- ============================================================================
-- 3. ATTENDANCE LOGS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.attendance_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    state text CHECK (state IN ('entrada', 'descanso', 'almuerzo', 'reunion', 'offline')),
    created_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.attendance_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users insert own logs" ON public.attendance_logs;
CREATE POLICY "Users insert own logs" ON public.attendance_logs 
FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users view own logs" ON public.attendance_logs;
CREATE POLICY "Users view own logs" ON public.attendance_logs 
FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins view all logs" ON public.attendance_logs;
CREATE POLICY "Admins view all logs" ON public.attendance_logs 
FOR SELECT USING (public.check_is_admin());

-- Indexes for attendance_logs
CREATE INDEX IF NOT EXISTS idx_attendance_logs_user_id ON public.attendance_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_created_at ON public.attendance_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_user_created ON public.attendance_logs(user_id, created_at DESC);

-- ============================================================================
-- 4. SCHEDULES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.schedules (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    scheduled_date date NOT NULL,
    start_time time NOT NULL,
    end_time time NOT NULL,
    break_start time,
    break_end time,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.schedules ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users view own schedules" ON public.schedules;
CREATE POLICY "Users view own schedules" ON public.schedules 
FOR SELECT USING (auth.uid() = user_id OR public.check_is_admin());

DROP POLICY IF EXISTS "Admins manage all schedules" ON public.schedules;
CREATE POLICY "Admins manage all schedules" ON public.schedules 
FOR ALL USING (public.check_is_admin());

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_updated_at_schedules ON public.schedules;
CREATE TRIGGER update_updated_at_schedules BEFORE UPDATE ON public.schedules 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Indexes for schedules
CREATE INDEX IF NOT EXISTS idx_schedules_user_id ON public.schedules(user_id);
CREATE INDEX IF NOT EXISTS idx_schedules_scheduled_date ON public.schedules(scheduled_date);
CREATE INDEX IF NOT EXISTS idx_schedules_user_date ON public.schedules(user_id, scheduled_date);

-- ============================================================================
-- 5. HR REQUESTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.hr_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    type text CHECK (type IN ('permiso', 'licencia', 'novedad', 'vacaciones', 'incapacidad')) DEFAULT 'novedad',
    status text CHECK (status IN ('pendiente', 'aprobado', 'rechazado')) DEFAULT 'pendiente',
    attachment_url text,
    details text,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.hr_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users manage own requests" ON public.hr_requests;
CREATE POLICY "Users manage own requests" ON public.hr_requests 
FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users view own requests" ON public.hr_requests;
CREATE POLICY "Users view own requests" ON public.hr_requests 
FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins manage all requests" ON public.hr_requests;
CREATE POLICY "Admins manage all requests" ON public.hr_requests 
FOR ALL USING (public.check_is_admin());

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_updated_at_hr_requests ON public.hr_requests;
CREATE TRIGGER update_updated_at_hr_requests BEFORE UPDATE ON public.hr_requests 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Indexes for hr_requests
CREATE INDEX IF NOT EXISTS idx_hr_requests_user_id ON public.hr_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_hr_requests_status ON public.hr_requests(status);
CREATE INDEX IF NOT EXISTS idx_hr_requests_created_at ON public.hr_requests(created_at DESC);

-- ============================================================================
-- 6. SHIFT EXCHANGE REQUESTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.shift_exchange_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    original_date date NOT NULL,
    requested_date date NOT NULL,
    requested_start_time time NOT NULL,
    requested_end_time time NOT NULL,
    reason text,
    status text CHECK (status IN ('pendiente', 'aprobado', 'rechazado')) DEFAULT 'pendiente',
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.shift_exchange_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users manage own shift requests" ON public.shift_exchange_requests;
CREATE POLICY "Users manage own shift requests" ON public.shift_exchange_requests 
FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins manage all shift requests" ON public.shift_exchange_requests;
CREATE POLICY "Admins manage all shift requests" ON public.shift_exchange_requests 
FOR ALL USING (public.check_is_admin());

-- Trigger for updated_at
DROP TRIGGER IF EXISTS update_updated_at_shift_exchange ON public.shift_exchange_requests;
CREATE TRIGGER update_updated_at_shift_exchange BEFORE UPDATE ON public.shift_exchange_requests 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Indexes for shift_exchange_requests
CREATE INDEX IF NOT EXISTS idx_shift_exchange_user_id ON public.shift_exchange_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_shift_exchange_status ON public.shift_exchange_requests(status);

-- ============================================================================
-- 7. PAYROLL TABLES
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.payroll_runs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    start_date date NOT NULL,
    end_date date NOT NULL,
    status text CHECK (status IN ('borrador', 'pagado')) DEFAULT 'borrador',
    total_paid numeric DEFAULT 0,
    created_by uuid REFERENCES auth.users NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT unique_payroll_period UNIQUE (start_date, end_date)
);

CREATE TABLE IF NOT EXISTS public.payroll_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    payroll_run_id bigint REFERENCES public.payroll_runs ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    base_salary numeric NOT NULL,
    minutes_worked numeric NOT NULL,
    total_pay numeric NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.payroll_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payroll_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Managers manage payroll" ON public.payroll_runs;
CREATE POLICY "Managers manage payroll" ON public.payroll_runs 
FOR ALL USING (public.check_is_admin());

DROP POLICY IF EXISTS "Managers manage payroll items" ON public.payroll_items;
CREATE POLICY "Managers manage payroll items" ON public.payroll_items 
FOR ALL USING (public.check_is_admin());

DROP POLICY IF EXISTS "Users view own payslips" ON public.payroll_items;
CREATE POLICY "Users view own payslips" ON public.payroll_items 
FOR SELECT USING (auth.uid() = user_id OR public.check_is_admin());

-- Triggers for updated_at
DROP TRIGGER IF EXISTS update_updated_at_payroll_runs ON public.payroll_runs;
CREATE TRIGGER update_updated_at_payroll_runs BEFORE UPDATE ON public.payroll_runs 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

DROP TRIGGER IF EXISTS update_updated_at_payroll_items ON public.payroll_items;
CREATE TRIGGER update_updated_at_payroll_items BEFORE UPDATE ON public.payroll_items 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- Indexes for payroll
CREATE INDEX IF NOT EXISTS idx_payroll_items_user_id ON public.payroll_items(user_id);
CREATE INDEX IF NOT EXISTS idx_payroll_items_payroll_run ON public.payroll_items(payroll_run_id);
CREATE INDEX IF NOT EXISTS idx_payroll_runs_status ON public.payroll_runs(status);

-- ============================================================================
-- 8. STORAGE CONFIGURATION
-- ============================================================================

INSERT INTO storage.buckets (id, name, public)
VALUES ('hr-attachments', 'hr-attachments', true)
ON CONFLICT (id) DO NOTHING;

DROP POLICY IF EXISTS "Authenticated users upload files" ON storage.objects;
CREATE POLICY "Authenticated users upload files" ON storage.objects
FOR INSERT TO authenticated WITH CHECK (bucket_id = 'hr-attachments');

DROP POLICY IF EXISTS "Authenticated users view own files" ON storage.objects;
CREATE POLICY "Authenticated users view own files" ON storage.objects
FOR SELECT TO authenticated USING (bucket_id = 'hr-attachments');

DROP POLICY IF EXISTS "Admins view all files" ON storage.objects;
CREATE POLICY "Admins view all files" ON storage.objects
FOR SELECT TO authenticated USING (bucket_id = 'hr-attachments');

-- ============================================================================
-- 9. AUTOMATION - NEW USER TRIGGER
-- ============================================================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'full_name', new.email),
    'empleado'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================================================
-- 10. DATA SYNC - Ensure all Auth users have profiles
-- ============================================================================

INSERT INTO public.profiles (id, full_name, role)
SELECT id, COALESCE(raw_user_meta_data->>'full_name', email), 'empleado'
FROM auth.users
ON CONFLICT (id) DO NOTHING;

-- Fix null roles
UPDATE public.profiles SET role = 'empleado' WHERE role IS NULL;

-- ============================================================================
-- 11. DEFAULT DATA - Role assignments (update as needed)
-- ============================================================================

-- These should be updated based on your actual user emails
UPDATE public.profiles
SET role = 'gerente'
WHERE id IN (SELECT id FROM auth.users WHERE email = 'gerente@smartfox.com');

UPDATE public.profiles
SET role = 'supervisor'
WHERE id IN (SELECT id FROM auth.users WHERE email = 'supervisor@smartfox.com');

-- ============================================================================
-- END OF SCHEMA
-- ========================================================================== */
