/* ==========================================================================
   SMART FOX SOLUTIONS - COMPLETE MASTER DATABASE SCHEMA
   Date: 2026-02-05
   Status: PRODUCTION-READY (RLS fixed, no recursion)
   ========================================================================== */

-- ============================================================================
-- 1. HELPER FUNCTIONS (SECURITY DEFINER - avoids RLS recursion)
-- ============================================================================

CREATE OR REPLACE FUNCTION public.check_is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND role IN ('supervisor', 'gerente')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- 2. PROFILES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    role text CHECK (role IN ('empleado', 'supervisor', 'gerente')) DEFAULT 'empleado',
    full_name text,
    document_id text,
    document_type text DEFAULT 'CC',
    hiring_date date DEFAULT CURRENT_DATE,
    contract_type text DEFAULT 'Indefinido',
    base_salary numeric DEFAULT 0,
    minute_rate numeric DEFAULT 0,
    personal_data jsonb DEFAULT '{"phone": "", "address": "", "city": "", "emergency_name": "", "emergency_phone": ""}'::jsonb,
    medical_data jsonb DEFAULT '{"eps": "", "arl": "", "blood_type": "", "allergies": "", "pension": ""}'::jsonb,
    sizes_data jsonb DEFAULT '{"shirt": "", "pants": "", "shoes": ""}'::jsonb,
    updated_at timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Clean up old policies
DROP POLICY IF EXISTS "Users view own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users insert own profile" ON public.profiles;
DROP POLICY IF EXISTS "Admins view all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Admins update all profiles" ON public.profiles;

-- Create profiles policies (no recursion - using SECURITY DEFINER function)
CREATE POLICY "Users view own profile" ON public.profiles 
FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users insert own profile" ON public.profiles 
FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users update own profile" ON public.profiles 
FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Admins view all profiles" ON public.profiles 
FOR SELECT USING (public.check_is_admin());

CREATE POLICY "Admins update all profiles" ON public.profiles 
FOR UPDATE USING (public.check_is_admin());

-- Trigger for minute rate calculation
CREATE OR REPLACE FUNCTION public.calculate_minute_rate()
RETURNS trigger AS $$
BEGIN
    IF NEW.base_salary IS DISTINCT FROM OLD.base_salary AND NEW.base_salary IS NOT NULL THEN
        -- Ley 2101 Colombia: 42 Horas Semanales -> 210 Horas Mensuales -> 12600 Minutos
        NEW.minute_rate := NEW.base_salary / 12600;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_minute_rate ON public.profiles;
CREATE TRIGGER update_minute_rate BEFORE INSERT OR UPDATE ON public.profiles 
FOR EACH ROW EXECUTE FUNCTION public.calculate_minute_rate();

DROP TRIGGER IF EXISTS update_updated_at_profiles ON public.profiles;
CREATE TRIGGER update_updated_at_profiles BEFORE UPDATE ON public.profiles 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role);

-- ============================================================================
-- 3. ATTENDANCE LOGS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.attendance_logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    state text CHECK (state IN ('entrada', 'descanso', 'almuerzo', 'reunion', 'offline')),
    created_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.attendance_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users insert own logs" ON public.attendance_logs;
DROP POLICY IF EXISTS "Users view own logs" ON public.attendance_logs;
DROP POLICY IF EXISTS "Admins view all logs" ON public.attendance_logs;

CREATE POLICY "Users insert own logs" ON public.attendance_logs 
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users view own logs" ON public.attendance_logs 
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Admins view all logs" ON public.attendance_logs 
FOR SELECT USING (public.check_is_admin());

CREATE INDEX IF NOT EXISTS idx_attendance_logs_user_id ON public.attendance_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_created_at ON public.attendance_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_attendance_logs_user_created ON public.attendance_logs(user_id, created_at DESC);

-- ============================================================================
-- 4. SCHEDULES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.schedules (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    scheduled_date date NOT NULL,
    start_time time NOT NULL,
    end_time time NOT NULL,
    break_start time,
    break_end time,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.schedules ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users view own schedules" ON public.schedules;
DROP POLICY IF EXISTS "Users insert own schedules" ON public.schedules;
DROP POLICY IF EXISTS "Admins create schedules" ON public.schedules;
DROP POLICY IF EXISTS "Admins manage all schedules" ON public.schedules;
DROP POLICY IF EXISTS "Admins update all schedules" ON public.schedules;

CREATE POLICY "Users view own schedules" ON public.schedules 
FOR SELECT USING (auth.uid() = user_id OR public.check_is_admin());

CREATE POLICY "Users insert own schedules" ON public.schedules 
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Admins create schedules" ON public.schedules 
FOR INSERT WITH CHECK (public.check_is_admin());

CREATE POLICY "Admins update all schedules" ON public.schedules 
FOR UPDATE USING (public.check_is_admin());

DROP TRIGGER IF EXISTS update_updated_at_schedules ON public.schedules;
CREATE TRIGGER update_updated_at_schedules BEFORE UPDATE ON public.schedules 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE INDEX IF NOT EXISTS idx_schedules_user_id ON public.schedules(user_id);
CREATE INDEX IF NOT EXISTS idx_schedules_scheduled_date ON public.schedules(scheduled_date);
CREATE INDEX IF NOT EXISTS idx_schedules_user_date ON public.schedules(user_id, scheduled_date);

-- ============================================================================
-- 5. HR REQUESTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.hr_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    type text CHECK (type IN ('permiso', 'licencia', 'novedad', 'vacaciones', 'incapacidad')) DEFAULT 'novedad',
    status text CHECK (status IN ('pendiente', 'aprobado', 'rechazado')) DEFAULT 'pendiente',
    attachment_url text,
    details text,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.hr_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users manage own requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Users view own requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Users insert own requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Users update own requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Admins manage all requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Admins view all requests" ON public.hr_requests;
DROP POLICY IF EXISTS "Admins update all requests" ON public.hr_requests;

CREATE POLICY "Users view own requests" ON public.hr_requests 
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users insert own requests" ON public.hr_requests 
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users update own requests" ON public.hr_requests 
FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Admins view all requests" ON public.hr_requests 
FOR SELECT USING (public.check_is_admin());

CREATE POLICY "Admins update all requests" ON public.hr_requests 
FOR UPDATE USING (public.check_is_admin());

DROP TRIGGER IF EXISTS update_updated_at_hr_requests ON public.hr_requests;
CREATE TRIGGER update_updated_at_hr_requests BEFORE UPDATE ON public.hr_requests 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE INDEX IF NOT EXISTS idx_hr_requests_user_id ON public.hr_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_hr_requests_status ON public.hr_requests(status);
CREATE INDEX IF NOT EXISTS idx_hr_requests_created_at ON public.hr_requests(created_at DESC);

-- ============================================================================
-- 6. SHIFT EXCHANGE REQUESTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.shift_exchange_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    original_date date NOT NULL,
    requested_date date NOT NULL,
    requested_start_time time NOT NULL,
    requested_end_time time NOT NULL,
    reason text,
    status text CHECK (status IN ('pendiente', 'aprobado', 'rechazado')) DEFAULT 'pendiente',
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.shift_exchange_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users manage own shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Users view own shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Users insert own shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Users update own shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Admins manage all shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Admins view all shift requests" ON public.shift_exchange_requests;
DROP POLICY IF EXISTS "Admins update all shift requests" ON public.shift_exchange_requests;

CREATE POLICY "Users view own shift requests" ON public.shift_exchange_requests 
FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users insert own shift requests" ON public.shift_exchange_requests 
FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users update own shift requests" ON public.shift_exchange_requests 
FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Admins view all shift requests" ON public.shift_exchange_requests 
FOR SELECT USING (public.check_is_admin());

CREATE POLICY "Admins update all shift requests" ON public.shift_exchange_requests 
FOR UPDATE USING (public.check_is_admin());

DROP TRIGGER IF EXISTS update_updated_at_shift_exchange ON public.shift_exchange_requests;
CREATE TRIGGER update_updated_at_shift_exchange BEFORE UPDATE ON public.shift_exchange_requests 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE INDEX IF NOT EXISTS idx_shift_exchange_user_id ON public.shift_exchange_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_shift_exchange_status ON public.shift_exchange_requests(status);

-- ============================================================================
-- 7. PAYROLL TABLES
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.payroll_runs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    start_date date NOT NULL,
    end_date date NOT NULL,
    status text CHECK (status IN ('borrador', 'pagado')) DEFAULT 'borrador',
    total_paid numeric DEFAULT 0,
    created_by uuid REFERENCES auth.users NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT unique_payroll_period UNIQUE (start_date, end_date)
);

CREATE TABLE IF NOT EXISTS public.payroll_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    payroll_run_id bigint REFERENCES public.payroll_runs ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    base_salary numeric NOT NULL,
    minutes_worked numeric NOT NULL,
    total_pay numeric NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

ALTER TABLE public.payroll_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payroll_items ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Managers manage payroll" ON public.payroll_runs;
DROP POLICY IF EXISTS "Managers manage payroll items" ON public.payroll_items;
DROP POLICY IF EXISTS "Users view own payslips" ON public.payroll_items;

CREATE POLICY "Managers manage payroll" ON public.payroll_runs 
FOR ALL USING (public.check_is_admin());

CREATE POLICY "Managers manage payroll items" ON public.payroll_items 
FOR ALL USING (public.check_is_admin());

CREATE POLICY "Users view own payslips" ON public.payroll_items 
FOR SELECT USING (auth.uid() = user_id OR public.check_is_admin());

DROP TRIGGER IF EXISTS update_updated_at_payroll_runs ON public.payroll_runs;
CREATE TRIGGER update_updated_at_payroll_runs BEFORE UPDATE ON public.payroll_runs 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

DROP TRIGGER IF EXISTS update_updated_at_payroll_items ON public.payroll_items;
CREATE TRIGGER update_updated_at_payroll_items BEFORE UPDATE ON public.payroll_items 
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE INDEX IF NOT EXISTS idx_payroll_items_user_id ON public.payroll_items(user_id);
CREATE INDEX IF NOT EXISTS idx_payroll_items_payroll_run ON public.payroll_items(payroll_run_id);
CREATE INDEX IF NOT EXISTS idx_payroll_runs_status ON public.payroll_runs(status);

-- ============================================================================
-- 8. STORAGE CONFIGURATION
-- ============================================================================

INSERT INTO storage.buckets (id, name, public)
VALUES ('hr-attachments', 'hr-attachments', true)
ON CONFLICT (id) DO NOTHING;

DROP POLICY IF EXISTS "Authenticated users upload files" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users view own files" ON storage.objects;
DROP POLICY IF EXISTS "Admins view all files" ON storage.objects;

CREATE POLICY "Authenticated users upload files" ON storage.objects
FOR INSERT TO authenticated WITH CHECK (bucket_id = 'hr-attachments');

CREATE POLICY "Authenticated users view own files" ON storage.objects
FOR SELECT TO authenticated USING (bucket_id = 'hr-attachments');

-- ============================================================================
-- 9. AUTOMATION - NEW USER TRIGGER
-- ============================================================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'full_name', new.email),
    'empleado'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================================================
-- 10. DATA SYNC - Ensure all Auth users have profiles
-- ============================================================================

INSERT INTO public.profiles (id, full_name, role)
SELECT id, COALESCE(raw_user_meta_data->>'full_name', email), 'empleado'
FROM auth.users
WHERE id NOT IN (SELECT id FROM public.profiles)
ON CONFLICT (id) DO NOTHING;

-- Fix any null roles
UPDATE public.profiles SET role = 'empleado' WHERE role IS NULL;

-- ============================================================================
-- 11. DEFAULT DATA - Role assignments
-- ============================================================================

-- Update as needed based on your actual user emails
UPDATE public.profiles
SET role = 'gerente'
WHERE id IN (SELECT id FROM auth.users WHERE email LIKE '%gerente%');

UPDATE public.profiles
SET role = 'supervisor'
WHERE id IN (SELECT id FROM auth.users WHERE email LIKE '%supervisor%');

-- ============================================================================
-- END OF COMPLETE SCHEMA
-- ========================================================================== */
